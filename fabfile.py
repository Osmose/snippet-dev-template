# TODO: Determine how to organize code
# TODO: Figure out a better way to edit the DB

import ConfigParser
import os
import select
import sqlite3

from fabric.decorators import task
from glob import glob
from os.path import isfile
from string import Template

BUILD_DIR = 'build'
BUILD_JS_FILE = BUILD_DIR + '/compiled.min.js'
BUILD_CSS_FILE = BUILD_DIR + '/compiled.css'
BUILD_OUT_FILE = BUILD_DIR + '/snippet.html'

SCRIPTS_DIR = 'scripts'
CSS_DIR = 'css'

SNIPPET_TEMPLATE_FILE = 'snippet_template.html'
SNIPPET_CONTENT_FILE = 'content.html'

config = ConfigParser.ConfigParser()
config.read('.snippetconfig')
database_present = config.has_section('Database')


@task
def monitor_build_push():
    """
    Monitors the current directory for changes and pushes when they happen
    """

    monitor = DirectoryMonitor('./')
    print "Monitoring for changes..."

    while True:
        if monitor.is_directory_changed():
            print "Change detected, pushing..."
            build_all_push()


class DirectoryMonitor:
    def __init__(self, path):
        directories = os.walk(path)

        self.kitems = []
        self.kq = select.kqueue()
        for d in directories:
            # Ignore .git and the like
            # TODO: Handle embedded dot directories
            if d[0].startswith('./.'):
                continue

            # Setup kqueue for monitoring
            directory = os.open(d[0], os.O_RDONLY)
            ke = select.kevent(directory, filter=select.KQ_FILTER_VNODE,
                               flags=select.KQ_EV_ADD | select.KQ_EV_ENABLE |
                               select.KQ_EV_CLEAR,
                               fflags=select.KQ_NOTE_DELETE |
                               select.KQ_NOTE_WRITE)
            self.kq.control([ke], 0, None)
            self.kitems.append((ke, directory))

    def __del__(self):
        for (ke, directory) in self.kitems:
            directory.close()

    def is_directory_changed(self):
        for (ke, directory) in self.kitems:
            raised_events = self.kq.control([ke], 1, None)
            for event in raised_events:
                if event.fflags & (select.KQ_NOTE_DELETE |
                                   select.KQ_NOTE_WRITE):
                    return True

        return False


@task
def build_all_push():
    build_all()
    push_to_db()


@task
def push_to_db():
    """
    Checks for database configuration info and pushes the last built snippet
    to the specified database
    """

    if (database_present):
        with open(BUILD_OUT_FILE, 'r') as snippet:
            conn = sqlite3.connect(config.get('Database', 'db_path'))
            conn.execute("""
                UPDATE homesnippets_snippet
                SET body=?
                WHERE id=?
            """, (snippet.read(), config.get('Database', 'snippet_id')))
            conn.commit()
            conn.close()


@task
def db_setup():
    """Setup database details and create snippet to push updates to."""

    if not config.has_section('Database'):
        config.add_section('Database')

    db_path = raw_input('Enter the absolute path to the sqlite '
                        'database file: ')

    while not _test_sqlite3_db(db_path):
        db_path = raw_input('Error validating database. Enter absolute path'
                            ' to database file (blank to quit setup): ')
        if not db_path:
            return

    config.set('Database', 'db_path', db_path)

    # Set up snippet to push to
    conn = sqlite3.connect(db_path)

    # Create Snippet
    conn.execute("""
        INSERT INTO homesnippets_clientmatchrule (description, exclude,
                                                  created, modified)
        VALUES ('Matches Anything', 0, datetime('now'), datetime('now'))
    """)
    client_rule_id = _get_last_insert_rowid(conn)

    # Create client rule
    conn.execute("""
        INSERT INTO homesnippets_snippet (name, body, disabled, preview,
                                           created, modified)
        VALUES (?, '', 0, 0, datetime('now'), datetime('now'))
    """, ('Autogenerated Snippet',))
    snippet_id = _get_last_insert_rowid(conn)

    # Associate snippet with rule
    conn.execute("""
        INSERT INTO homesnippets_snippet_client_match_rules
            (snippet_id, clientmatchrule_id)
        VALUES (?, ?)
    """, (snippet_id, client_rule_id))

    conn.commit()
    conn.close()

    config.set('Database', 'snippet_id', snippet_id)
    config.set('Database', 'client_rule_id', client_rule_id)

    # TODO: Handle failure better
    with open('.snippetconfig', 'w') as f:
        config.write(f)


def _get_last_insert_rowid(conn):
    cursor = conn.execute('SELECT last_insert_rowid()')
    result = cursor.fetchone()
    if result is not None:
        return result[0]
    else:
        return None


def _test_sqlite3_db(db_path):
    """Very basic test for validity of database."""

    # Check for file existance and if it's a sqlite3 db
    if isfile(db_path):
        try:
            conn = sqlite3.connect(db_path)

            # TODO: If we really care, do a more thorough check
            # If it has the homesnippets_snippet table we're content
            tables = [r[0] for r in conn.execute("""
                SELECT name FROM sqlite_master
                WHERE type='table'
            """).fetchall()]
            conn.close()

            if 'homesnippets_snippet' in tables:
                return True
        except sqlite3.DatabaseError:
            pass

    return False


@task
def build_all():
    combine_js()
    combine_css()
    build_snippet()


@task
def combine_js():
    """Combines every .js file in the SCRIPTS_DIR into one script."""

    _combine_files(SCRIPTS_DIR + '/*.js', BUILD_JS_FILE)


@task
def combine_css():
    """Combines every .css file in the CSS_DIR into one file."""

    _combine_files(CSS_DIR + '/*.css', BUILD_CSS_FILE)


def _combine_files(glob_mask, combined_file_name):
    """Combines all files that match glob_mask into one file."""

    files = []
    for file in glob(glob_mask):
        with open(file, 'r') as f:
            files.append(f.read())

    with open(combined_file_name, 'w') as f:
        f.write('\n'.join(files))


@task
def build_snippet():
    """
    Combines the compiled JS, CSS, and content into the template and outputs
    the result.
    """

    js_file = open(BUILD_JS_FILE, 'r')
    css_file = open(BUILD_CSS_FILE, 'r')
    template_file = open(SNIPPET_TEMPLATE_FILE, 'r')
    content_file = open(SNIPPET_CONTENT_FILE, 'r')

    template = Template(template_file.read())
    compiled = template.substitute({
        'css': css_file.read(),
        'js': js_file.read(),
        'content': content_file.read()
    })

    content_file.close()
    template_file.close()
    css_file.close()
    js_file.close()

    output_file = open(BUILD_OUT_FILE, 'w')
    output_file.write(compiled)
    output_file.close()
